const { compile } = require("@riotjs/compiler");

const { getOptions } = require("loader-utils");

/**
 * Generate the hmr code depending on the tags generated by the compiler
 * @param   { Array } tags - array of strings
 * @returns { string } the code needed to handle the riot hot reload
 */
function hotReload(tags) {
  // must sync with the definition in @riotjs/custom-components
  const COMPONENT_NAME_POSTFIX = "native-component";

  return `
  if (module.hot) {
    module.hot.accept()
    if (module.hot.data) {
      ${tags
        .map(tag => `riot.reload('${tag}-${COMPONENT_NAME_POSTFIX}')`)
        .join("\n")}
    }
  }`;
}

module.exports = function(source) {
  // tags collection
  const tags = [];

  // parse the user query
  const query = getOptions(this) || {};

  // normalise the query object in case of question marks
  const opts = Object.keys(query).reduce(function(acc, key) {
    acc[key.replace("?", "")] = query[key];
    return acc;
  }, {});

  // cache this module
  if (this.cacheable) this.cacheable();

  // compile to generate entities
  const callback = this.async();
  compile(source, opts).then(({ code, map }) => {
    code += opts.hot ? hotReload(tags) : '';
    callback(null, code, map);
  }).catch(err => {
    callback(err);
  });
};
