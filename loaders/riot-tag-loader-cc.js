const riotParser = require("@riotjs/parser").default;
/* EXPERIMENTAL:
 * Adopting riot-compiler v4
 * Issues:
 * 1. It provide only async `compile`. Can we use it in loader?
 * 2. No `entities` options and lacks `attribs` field.
  *   => Can riot-parser solve this?
 */
const { getOptions } = require("loader-utils");
const escapeJs = require("./escapeJs");
const printAst = require("./printAst");

/**
 * Generate the hmr code depending on the tags generated by the compiler
 * @param   { Array } tags - array of strings
 * @returns { string } the code needed to handle the riot hot reload
 */
function hotReload(tags) {
  // must sync with the definition in @riotjs/custom-components
  const COMPONENT_NAME_POSTFIX = "native-component";

  return `
  if (module.hot) {
    module.hot.accept()
    if (module.hot.data) {
      ${tags
        .map(tag => `riot.reload('${tag}-${COMPONENT_NAME_POSTFIX}')`)
        .join("\n")}
    }
  }`;
}

/**
 * transform the script written in riot@v4 form to IIFE.
 *
 * @param {String} javascript - code
 */
function transformScript(javascript) {
  let found = false;
  const replaced = javascript.replace(/export\s+default/, () => {
    found = true;
    return 'var __default =';
  });

  return `(function () {
  ${replaced}
  ${found ? 'return __default;' : ''}
} ())`;

  // TODO: sourcemap?
}

module.exports = function(source) {
  // tags collection
  const tags = [];

  // parse the user query
  const query = getOptions(this) || {};

  // normalise the query object in case of question marks
  const opts = Object.keys(query).reduce(function(acc, key) {
    acc[key.replace("?", "")] = query[key];
    return acc;
  }, {});

  // compile to generate entities
  const { parse } = riotParser(opts.parserOpts || {});
  const parseResult = parse(source);
  const { template, css, javascript } = parseResult.output;

  console.log(css);
  const tagName = template.name;
  const html = printAst(parseResult.data, template.nodes);
  const style = css ? css.text.text : '';
  const props = template.attributes.map(x => x.name);
  const data = template.attributes.reduce((acc, x) => { acc[x.name] = x.isBoolean? !!x.value : x.value; return acc; }, {})
  const api = transformScript(javascript.text.text);

  const output = `
import define from '@riotjs/custom-elements';

var component = {
  css: '${escapeJs(style)}',
  tmpl: '${escapeJs(html)}',
  props: ['${props.map(escapeJs).join('\',\'')}'],
  data() {
    return ${JSON.stringify(data)};
  }
};

var api = ${api};

Object.assign(component, api);

define('${tagName}', component);

${opts.hot ? hotReload(tags) : ""}
`;

  // cache this module
  if (this.cacheable) this.cacheable();

  // TODO: generate sourcemaps

  console.log('$$$$$----------=$$$$')
  console.log(output);

  return output;
  //this.callback(output);
};
